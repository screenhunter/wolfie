{"version":3,"sources":["/home/havvy/tennu/tennu/src/lib/message-handler.sjs"],"names":["util","require","EventEmitter","Message","Promise","Response","MessageParser","MP","client","logger","socket","parser","Object","create","isupport","parse","raw","message","error","emit","command","toLowerCase","replyname","listen","socket$2","on","bind","after","err","res","type","stack","channel","undefined","resolve","then","a","send","catch","logBadResponseError","err$2","format","badResponseFormat","inspect","toString","value","module","exports"],"mappings":"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","file":"message-handler.js","sourcesContent":["/**\n * This event emitter listens to an IRC Socket and converts all messages to\n * Message objects which it emits under events of the Message.command field.\n *\n * If the listeners return a value, that value is broadcast to the location\n * that the event originated from, should the event originate from a channel\n * or private message.\n *\n * Numeric events are sent by both numeric and reply name.\n *\n * Example events:\n *  join\n *  error (when quitting/forced to quit)\n *  005\n *  rpl_endofwhois\n *\n * All messages can be listened to with the '*' event.\n *\n * The constructor takes three arguments:\n *   1. client - The nominal client of the message.\n *   2. logger - Logger object.\n *   3. socket - <Optional> EventEmitter emitting ('data', RFC1459Message)\n *\n * MessageParser.parse(raw: String): irc-message-extended.Message\n *   Parses the message, \n *   emits the message event, and the '*' event,\n *   and returns the message.\n *\n * MessageParser#listen(socket: Socket): void\n *   Subscribes the message parser to the socket, parsing anything sent\n *   through the 'data' event.\n *\n * MessageParser#toString(): String\n *   Returns '[Object MessageParser]'.\n */\n\nvar util = require('util');\nvar EventEmitter = require('after-events');\nvar Message = require('./message');\nvar Promise = require('bluebird');\nvar Response = require('./response');\n\nvar MessageParser = function MP (client, logger, socket) {\n    var parser = Object.create(EventEmitter());\n    var isupport;\n\n    parser.parse = function (raw) {\n        var message = new Message(raw, isupport);\n\n        if (message === null) {\n            logger.error(\"Raw message given was not a valid IRC message!\", raw);\n            return null;\n        }\n\n        this.emit(message.command.toLowerCase(), message);\n\n        if (message.replyname) {\n            this.emit(message.replyname.toLowerCase(), message);\n        }\n\n        this.emit(\"*\", message);\n\n        return message;\n    };\n\n    parser.listen = function (socket) {\n        socket.on('data', this.parse.bind(this));\n    };\n\n    parser.after(function (err, res, type, message) {\n        // Intent := \"say\" | \"act\" | \"ctcp\" | \"notice\" | \"none\"\n        // Target: NickName | ChannelName\n        // ReturnResponse := {message: String | [CtcpType, CtcpBody], intent: Intent, target: Target, query: Boolean}\n        // Result = undefined | string | [string] | ReturnResponse\n\n        // err := Error\n        // res := Result | Promise<Result>\n        // type := string\n        // message := Message\n\n        if (err) {\n            logger.error('Message Handler', 'Error thrown in message handler!');\n            logger.error('Message Handler', err.stack);\n            return;\n        }\n\n        if (message.channel !== undefined) {\n            Promise.resolve(res)\n            .then(λ[Response.create(#, message)])\n            .then(λ[Response.send(#, client)])\n            .catch(logBadResponseError)\n        }\n\n        function logBadResponseError (err) {\n            logger.error('Message Handler', format(badResponseFormat, message.message, inspect(res)));\n        }\n    });\n\n    parser.toString = λ[\"[Object MessageParser]\"];\n\n    parser.isupport = function (value) {\n        isupport = value;\n    };\n\n    if (socket) {\n        parser.listen(socket);\n    }\n\n    return parser;\n};\n\nmodule.exports = MessageParser;"],"sourceRoot":"/source/"}